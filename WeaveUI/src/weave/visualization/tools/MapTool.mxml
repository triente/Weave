<?xml version="1.0" encoding="utf-8"?>
<!--
/*
    Weave (Web-based Analysis and Visualization Environment)
    Copyright (C) 2008-2011 University of Massachusetts Lowell

    This file is a part of Weave.

    Weave is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License, Version 3,
    as published by the Free Software Foundation.

    Weave is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Weave.  If not, see <http://www.gnu.org/licenses/>.
*/
-->
<SimpleVisTool xmlns="weave.visualization.tools.*" 
	     xmlns:mx="http://www.adobe.com/2006/mxml"
	     xmlns:ui="weave.ui.*"
	     layout="absolute" xmlns:userControls="weave.ui.userControls.*" creationPolicy="all"
	     xmlns:mapTool="weave.visualization.tools.*" xmlns:managers="weave.editors.managers.*"
	     >
	<mx:Script>
		<![CDATA[
			import mx.controls.CheckBox;
			
			import weave.api.data.IKeySet;
			
			import mx.utils.ObjectUtil;
			
			import weave.Weave;
			import weave.api.WeaveAPI;
			import weave.api.copySessionState;
			import weave.api.getCallbackCollection;
			import weave.api.linkBindableProperty;
			import weave.api.linkSessionState;
			import weave.api.registerLinkableChild;
			import weave.api.data.ColumnMetadata;
			import weave.api.data.DataTypes;
			import weave.api.data.IAttributeColumn;
			import weave.api.primitives.IBounds2D;
			import weave.api.ui.IPlotter;
			import weave.api.ui.IVisTool;
			import weave.core.LinkableBoolean;
			import weave.core.LinkableNumber;
			import weave.core.LinkableString;
			import weave.core.SessionManager;
			import weave.core.UIUtils;
			import weave.data.AttributeColumns.DynamicColumn;
			import weave.data.AttributeColumns.ReferencedColumn;
			import weave.data.AttributeColumns.ReprojectedGeometryColumn;
			import weave.primitives.Bounds2D;
			import weave.services.wms.WMSProviders;
			import weave.ui.ColorController;
			import weave.ui.DraggablePanel;
			import weave.ui.DynamicColumnComponent;
			import weave.ui.SubMenu;
			import weave.utils.ColumnUtils;
			import weave.utils.ProbeTextUtils;
			import weave.visualization.layers.InteractionController;
			import weave.visualization.layers.LayerSettings;
			import weave.visualization.plotters.AbstractGlyphPlotter;
			import weave.visualization.plotters.GeometryLabelPlotter;
			import weave.visualization.plotters.GeometryPlotter;
			import weave.visualization.plotters.GeometryRelationPlotter;
			import weave.visualization.plotters.SingleImagePlotter;
			import weave.visualization.plotters.WMSPlotter;

			WeaveAPI.registerImplementation(IVisTool, MapTool, "Map");
			
			protected static const locationsList:Array = [lang("Top left"), lang("Top right"), lang("Bottom left"), lang("Bottom right")];
			public const maptoolsLocation:LinkableNumber = registerLinkableChild(this, new LinkableNumber(0), handleLocationChange, true);
			
			// no main plotter
			override protected function get mainPlotter():IPlotter { return null; }
			
			override protected function constructor():void
			{
				super.constructor();
			}
			
			private var selectionSubMenu:SubMenu;
			
			override public function getSelectableAttributeNames():Array
			{
				return ["Color"];
			}
			override public function getSelectableAttributes():Array
			{
				return [colorColumn];
			}
			
			/**
			 * This function moves the overview window in front of the visualization
			 */
			private function bringOverviewToTop():void
			{
				children.setNameOrder([OVERVIEW_PANEL_NAME]);
			}
			
			/**
			 * This is the projection of the map visualization.
			 */
			public const projectionSRS:LinkableString = registerLinkableChild(this, new LinkableString(null, projectionVerifier));
			// this function returns true if the projection SRS code is acceptable
			private function projectionVerifier(srs:String):Boolean
			{
				// allow no projection
				if (srs == null || srs == '')
					return true;
				return WeaveAPI.ProjectionManager.projectionExists(srs);
			}
			
			public const includeToolAttributesInProbe:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(true), updateProbeColumns);
			
			// the keys in this Dictionary are LinkableStrings that have been linked to projectionSRS.
			private var _linkedProjectionVariablesLookup:Dictionary = new Dictionary(true);
			[Bindable] private var _projComboBoxData:Array = [];
			
			/**
			 * This function links the MapTool.projectionSRS variable with another LinkableString.
			 */
			private function linkProjection(otherVariable:LinkableString):void
			{
				if (_linkedProjectionVariablesLookup[otherVariable])
					return;
				_linkedProjectionVariablesLookup[otherVariable] = true;
				
				// if map tool specifies a valid projection, use map tool value as the primary value
				if (WeaveAPI.ProjectionManager.projectionExists(projectionSRS.value))
					linkSessionState(projectionSRS, otherVariable);
				else
					linkSessionState(otherVariable, projectionSRS);
			}
			
			private function handleLayerSettingsChange():void
			{
				visualization.plotManager.layerSettings.delayCallbacks();
				
				// prevent WMS layers from being selectable
				for each (var name:String in visualization.plotManager.plotters.getNames(WMSPlotter))
					visualization.plotManager.getLayerSettings(name).selectable.value = false;
				
				visualization.plotManager.layerSettings.resumeCallbacks();
			}
			private function handlePlottersChange():void
			{
				_projComboBoxData.length = 0;
				// TEMPORARY: set the selected item in the combo box because changing the data provider 
				// will reset the text field
				if (WeaveAPI.ProjectionManager.projectionExists(projectionSRS.value))
				{
					_projComboBoxData.push(projectionSRS.value);
					projComboBox.selectedItem = projectionSRS.value; 
				}
				
				var projString:String;
				
				// make sure glyph layer projections are identical
				var glyphPlotters:Array = WeaveAPI.SessionManager.getLinkableDescendants(visualization.plotManager.plotters, AbstractGlyphPlotter);
				for each (var glyphPlotter:AbstractGlyphPlotter in glyphPlotters)
				{
					linkProjection(glyphPlotter.destinationProjection);
					projString = glyphPlotter.sourceProjection.value;
					if (projString && _projComboBoxData.indexOf(projString) < 0)
						_projComboBoxData.push(projString);
				}
				
				// make sure wms layer projections are identical
				var wmsPlotters:Array = WeaveAPI.SessionManager.getLinkableDescendants(visualization.plotManager.plotters, WMSPlotter);
				for each (var wmsPlotter:WMSPlotter in wmsPlotters)
				{
					linkProjection(wmsPlotter.srs);
					projString = WMSProviders.getSRS(wmsPlotter.providerName);
					if (projString && _projComboBoxData.indexOf(projString) < 0)
						_projComboBoxData.push(projString);
				}
				
				// make sure all geometry column projections are identical
				var reprojectedColumns:Array = WeaveAPI.SessionManager.getLinkableDescendants(visualization.plotManager.plotters, ReprojectedGeometryColumn);
				for each (var column:ReprojectedGeometryColumn in reprojectedColumns)
				{
					linkProjection(column.projectionSRS);
					projString = column.internalDynamicColumn.getMetadata(ColumnMetadata.PROJECTION);
					if (projString && _projComboBoxData.indexOf(projString) < 0)
						_projComboBoxData.push(projString);					
				}
				
				updateProbeColumns();
			}
			private function updateProbeColumns():void
			{
				if (includeToolAttributesInProbe.value)
				{
					visualization.additionalProbeColumns = [];
					// get all ReferencedColumn objects, excluding geometry columns
					var refCols:Array = WeaveAPI.SessionManager.getLinkableDescendants(visualization, ReferencedColumn);
					for each (var col:IAttributeColumn in refCols)
						if (ObjectUtil.stringCompare(ColumnUtils.getDataType(col), DataTypes.GEOMETRY, true) != 0) // non-geometry
							visualization.additionalProbeColumns.push(col);
				}
				else
					visualization.additionalProbeColumns = null;
			}
			
			override protected function get defaultPanelTitle():String
			{
				return "Map " + (colorColumn.getInternalColumn() == null ? '' : "of " + ColumnUtils.getTitle(colorColumn));
			}
			
			override protected function createChildren():void
			{
				super.createChildren();
				
				var backgroundImageCheck:CheckBox = new CheckBox();
				backgroundImageCheck.label = "Enable ocean background image";
				linkBindableProperty(enableBackground, backgroundImageCheck, "selected");
				windowSettingsEditor.initialize();
				windowSettingsEditor.addChild(backgroundImageCheck);
				windowSettingsEditor.removeChild(windowSettingsEditor.titleControls);
				
				windowSettingsEditor.addChildAt(simpleAxisEditor.titleControls, 0);
				simpleAxisEditor.parent.removeChild(simpleAxisEditor);
				
				if (visualization.plotManager.plotters.getNames().length == 0)
					addGeomLayer();
			}
			
			override protected function childrenCreated():void
			{
				super.childrenCreated();
				
				// make sure WMS layers are included in the full data bounds
				visualization.plotManager.includeNonSelectableLayersInAutoZoom.value = true;
				visualization.plotManager.includeNonSelectableLayersInAutoZoom.lock();
				
				visualization.plotManager.enableFixedAspectRatio.value = true;
				visualization.plotManager.enableAutoZoomToExtent.value = false;
				getCallbackCollection(visualization).addGroupedCallback(this, updateZoomSlider);
				
				colorColumn.addGroupedCallback(this, handlePanelTitleChange);
				Weave.properties.toolInteractions.defaultDragMode.addGroupedCallback(this, handleMouseModeChange);
				
				visualization.plotManager.plotters.addGroupedCallback(this,handlePlottersChange,true);
				visualization.plotManager.plotters.addGroupedCallback(this,handleLayerSettingsChange,true);
				colorColumn.addGroupedCallback(this,updateProbeColumns, true);
				
				linkBindableProperty(visualization.plotManager.minZoomLevel, this, "zoomSliderMinimum");
				linkBindableProperty(visualization.plotManager.maxZoomLevel, this, "zoomSliderMaximum");
				
				getCallbackCollection(visualization.plotManager.zoomBounds).addGroupedCallback(this, handleBoundsChange, true);
				
				
				
				selectionSubMenu = new SubMenu(selectModeButton,[MouseEvent.MOUSE_DOWN],[MouseEvent.MOUSE_UP]);
				
				selectionSubMenu.addSubMenuItem(lang("Rectangular Selection"),function():void{
					Weave.properties.toolInteractions.defaultDragMode.value = InteractionController.SELECT;
					Weave.properties.selectionMode.value = InteractionController.SELECTION_MODE_RECTANGLE;});
				
				selectionSubMenu.addSubMenuItem(lang("Circular Selection"),function():void{
					Weave.properties.toolInteractions.defaultDragMode.value = InteractionController.SELECT;
					Weave.properties.selectionMode.value = InteractionController.SELECTION_MODE_CIRCLE;});
				
				selectionSubMenu.addSubMenuItem(lang("Lasso Selection"),function():void{
					Weave.properties.toolInteractions.defaultDragMode.value = InteractionController.SELECT;
					Weave.properties.selectionMode.value = InteractionController.SELECTION_MODE_LASSO;});
			}
			
			private function handleMouseModeChange(event:Event = null):void
			{
				var defaultMode:String;
				if (event)
				{
					switch (event.target)
					{
						case panModeButton:
							defaultMode = InteractionController.PAN;
							break;
						default:
						case selectModeButton:
							defaultMode = InteractionController.SELECT;
							break;
						case selectModeSubtractButton:
							defaultMode = InteractionController.SELECT_REMOVE;
							break;
						case selectModeAddButton:
							defaultMode = InteractionController.SELECT_ADD;
							break;
						case zoomModeButton:
							defaultMode = InteractionController.ZOOM;
							Weave.properties.selectionMode.value = InteractionController.SELECTION_MODE_RECTANGLE; //to draw the blue rectangle
							break;
					}
					Weave.properties.toolInteractions.defaultDragMode.value = defaultMode;
				}
				defaultMode = Weave.properties.toolInteractions.defaultDragMode.value;
				
				var buttonMap:Object = {};
				buttonMap[InteractionController.PAN] = panModeButton;
				buttonMap[InteractionController.SELECT] = selectModeButton;
				buttonMap[InteractionController.SELECT_REMOVE] = selectModeSubtractButton;
				buttonMap[InteractionController.SELECT_ADD] = selectModeAddButton;
				buttonMap[InteractionController.ZOOM] = zoomModeButton;
				var selectedButton:Button = buttonMap[defaultMode];
				for each (var button:Button in buttonMap)
					button.selected = (button == selectedButton);
			}
			
			
			public function get colorColumn():DynamicColumn
			{
				return Weave.defaultColorDataColumn.internalDynamicColumn;
			}
			
			
			private function setCenterCoords():void
			{
//				var x:Number = MathLib.toNumber(xCenterCoord.text);
//				var y:Number = MathLib.toNumber(yCenterCoord.text);
//				visualization.dataBounds.copyTo(_tempBounds);
//				_tempBounds.setCenter(x, y);
//				visualization.dataBounds.copyFrom(_tempBounds);
			}
			
			public function updateZoomSlider():void
			{
				if (zoomSlider)
				{
					currentlyUpdatingZoomSlider = true;
					scaleRangeTabZoomSlider.value = zoomSlider.value = visualization.getZoomLevel();
					currentlyUpdatingZoomSlider = false;
				}
			}
			private var currentlyUpdatingZoomSlider:Boolean = false;
			
			private function handleZoomSliderChange(event:Event):void
			{
				if (!currentlyUpdatingZoomSlider)
					visualization.setZoomLevel(event.currentTarget.value);
			}
			
			private function handleZoomInClick():void
			{
				visualization.plotManager.zoomBounds.getDataBounds(_tempBounds);
				_tempBounds.centeredResize(
					_tempBounds.getWidth() / visualization.zoomFactor.value,
					_tempBounds.getHeight() / visualization.zoomFactor.value
				);
				visualization.plotManager.setCheckedZoomDataBounds(_tempBounds);
			}
			
			private function handleZoomOutClick():void
			{
				visualization.plotManager.zoomBounds.getDataBounds(_tempBounds);
				_tempBounds.centeredResize(
					_tempBounds.getWidth() * visualization.zoomFactor.value,
					_tempBounds.getHeight() * visualization.zoomFactor.value
				);
				visualization.plotManager.setCheckedZoomDataBounds(_tempBounds);
			}
			
			private function handlePanButtonClick(xPan:Number, yPan:Number):void
			{
				var panPercent:Number = 0.3;
				
				visualization.plotManager.zoomBounds.getDataBounds(_tempBounds);
				_tempBounds.offset(
						_tempBounds.getWidth() * panPercent * xPan,
						_tempBounds.getHeight() * panPercent * yPan
					);
				visualization.plotManager.setCheckedZoomDataBounds(_tempBounds);
			}
			
			private var _tempBounds:IBounds2D = new Bounds2D();

			[Embed(source="/weave/resources/images/ocean_background2.jpg")]
			private static const BackgroundImage:Class;
			private static const backgroundImageBitmapData:BitmapData = (new BackgroundImage() as Bitmap).bitmapData;
			
			public const enableBackground:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(false), invalidateDisplayList);
			public const enableOverview:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(false), updateOverviewWindow);
			
			override protected function updateDisplayList(unscaledWidth:Number, unscaledHeight:Number):void
			{
				super.updateDisplayList(unscaledWidth, unscaledHeight);
				
				visualization.graphics.clear();
				if (enableBackground.value)
				{
					visualization.graphics.lineStyle(0,0,0);
					visualization.graphics.beginBitmapFill(backgroundImageBitmapData);
					visualization.graphics.drawRect(0, 0, visualization.width, visualization.height);
				}
			}
			
			private function addGeomLayer():void
			{
				var name:String = visualization.plotManager.plotters.generateUniqueName("plot");
				visualization.plotManager.plotters.requestObject(name, GeometryPlotter, false);
			}
			
			private function addLabelLayer():void
			{
				var i:int;
				// get existing layers before they change
				var layerNames:Array = visualization.plotManager.plotters.getNames().reverse(); // top to bottom
				// if a layer is selected in the editor, check that one first.
				if (visualization.plotManager.getPlotter(layerEditor.selectedItem as String))
					layerNames.unshift(layerEditor.selectedItem);
				// create new label layer
				var labelLayerName:String = visualization.plotManager.plotters.generateUniqueName("label");
				var labelPlotter:GeometryLabelPlotter = visualization.plotManager.plotters.requestObject(labelLayerName, GeometryLabelPlotter, false);
				// loop through existing layers to find geometry layer that we can add corresponding labels for
				for each (var layerName:String in layerNames)
				{
					var geomPlotter:GeometryPlotter = visualization.plotManager.getPlotter(layerName) as GeometryPlotter;
					if (geomPlotter)
					{
						// found a geometry layer
						copySessionState(geomPlotter.geometryColumn, labelPlotter.geometryColumn);
						// see if there is a matching column in probe headers
						var headers:Array = ProbeTextUtils.probeHeaderColumns.getObjects();
						for (i = 0; i < headers.length; i++)
						{
							if (ColumnUtils.getKeyType(headers[i]) == ColumnUtils.getKeyType(geomPlotter.geometryColumn))
							{
								labelPlotter.text.requestLocalObjectCopy(headers[i]);
								break;
							}
						}
						// stop when we found geometry layer
						break;
					}
				}
			}
			
			private function addRelationLayer():void
			{
				var i:int;
				// get existing layers before they change
				var layerNames:Array = visualization.plotManager.plotters.getNames().reverse(); // top to bottom
				// if a layer is selected in the editor, check that one first.
				if (visualization.plotManager.getPlotter(layerEditor.selectedItem as String))
					layerNames.unshift(layerEditor.selectedItem);
				// create new label layer
				var relationLayerName:String = visualization.plotManager.plotters.generateUniqueName("relation");
				var relationPlotter:GeometryRelationPlotter = visualization.plotManager.plotters.requestObject(relationLayerName, GeometryRelationPlotter, false);
				// loop through existing layers to find geometry layer that we can add corresponding labels for
				for each (var layerName:String in layerNames)
				{
					var geomPlotter:GeometryPlotter = visualization.plotManager.getPlotter(layerName) as GeometryPlotter;
					if (geomPlotter)
					{
						// found a geometry layer
						copySessionState(geomPlotter.geometryColumn, relationPlotter.geometryColumn);
						// stop when we found geometry layer
						break;
					}
				}
			}
			// ToDo
//			private var dataBounds:Bounds2D = new Bounds2D();
//			private var screenBounds:Bounds2D = new Bounds2D();
//			private function drawProbeLines():void
//			{ 
//				if(!Weave.properties.enableProbeLines.value) return;
//				
//				var probeKeySet:IKeySet = (mainLayerSettings.probeFilter.internalObject) as IKeySet;
//				if (!probeKeySet)
//					return;
//				
//				visualization.plotManager.zoomBounds.getDataBounds(dataBounds);
//				visualization.plotManager.zoomBounds.getScreenBounds(screenBounds);
//				
//				_plotter.probedKeys = probeKeySet.keys ;
//				_plotter.drawProbe = (this as DraggablePanel) == DraggablePanel.activePanel;
//				
//				_plotter.drawProbeLines(dataBounds, screenBounds, probeSprite.graphics);	
//				
//			}
			
			private function addWMSLayer():void
			{
				var oldLayerNames:Array = visualization.plotManager.plotters.getNames();
				
				var name:String = visualization.plotManager.plotters.generateUniqueName("wms");
				visualization.plotManager.plotters.requestObject(name, WMSPlotter, false);
				visualization.plotManager.getLayerSettings(name).selectable.value = false;
				
				// put old layers on top
				visualization.plotManager.plotters.setNameOrder(oldLayerNames);
			}

			private function handleBoundsChange():void
			{
				// update center coordinates text boxes
				visualization.plotManager.zoomBounds.getDataBounds(_tempBounds);
				xCenterCoord.text = String(_tempBounds.getXCenter());
				yCenterCoord.text = String(_tempBounds.getYCenter());
			}
			
			public var overviewPanel:MapOverviewWindow;
			private const OVERVIEW_PANEL_NAME:String = "overview";
			
			private function updateOverviewWindow():void
			{				
				if (enableOverview.value)
				{
					overviewPanel = children.requestObject(OVERVIEW_PANEL_NAME, MapOverviewWindow, false); //not locked because it should be removable
					// catercorner to the mapControls 
					if (mapControls.top == 0)
						overviewPanel.panelY.value = "75%";
					if (mapControls.left == 0)
						overviewPanel.panelX.value = "75%";
					if (mapControls.bottom == 0)
						overviewPanel.panelY.value = "0%";
					if (mapControls.right == 0)
						overviewPanel.panelX.value = "0%";

					// remove overview window from parent's session state
					(WeaveAPI.SessionManager as SessionManager).excludeLinkableChildFromSessionState(children, overviewPanel);
					linkSessionState(visualization.plotManager.layerSettings, overviewPanel.visualization.plotManager.layerSettings);
					linkSessionState(visualization.plotManager.plotters, overviewPanel.visualization.plotManager.plotters);
					overviewPanel.parentZoomBounds = visualization.plotManager.zoomBounds;
					children.addGroupedCallback(this, bringOverviewToTop);
				}
				else
				{
					children.removeObject(OVERVIEW_PANEL_NAME);
				}
			}
			
			public function addMarker(name:String,url:String,x:Number,y:Number,width:Number=NaN,height:Number=NaN):void
			{
				var marker:SingleImagePlotter = visualization.plotManager.plotters.requestObject(name, SingleImagePlotter, false);
				
				marker.imageURL.value = url;
				
				marker.dataX.value = x;
				marker.dataY.value = y;
				
				marker.dataWidth.value = width;
				marker.dataHeight.value = height;
			}



			public const showZoomControls:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(true));
			public const showMouseModeControls:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(true));
			
			private const _tempArray:Array = [];
			
			private function handleProjectionComboChange():void
			{
				if (UIUtils.hasFocus(projComboBox))
				{
					// clear all layer visibility settings because they are no longer valid in the new projection
					visualization.plotManager.layerSettings.delayCallbacks();
					for each (var settings:LayerSettings in visualization.plotManager.layerSettings.getObjects())
					{
						settings.minVisibleScale.value = 0;
						settings.maxVisibleScale.value = Infinity;
					}
					visualization.plotManager.layerSettings.resumeCallbacks();
				}
				if (projectionVerifier(projComboBox.text))
				{
					projValidLabel.text = 'Valid';
					projComboBox.errorString = '';
				}
				else
				{
					projValidLabel.text = 'Invalid';
					projComboBox.errorString = 'Unknown projection';
				}
			}
			
			public function handleLocationChange():void 
			{
				if (!parent)
				{
					callLater(handleLocationChange);
					return;
				}
				
				clearMapcontroLocations();
				switch (maptoolsLocation.value)
				{
					case 0:
						mapControls.top = 0;
						mapControls.left = 0;
						break;
					case 1:
						mapControls.top = 0;
						mapControls.right = 0;
						break;
					case 2:
						mapControls.bottom = 0;
						mapControls.left = 0;
						break;
					case 3:
						mapControls.bottom = 0;
						mapControls.right = 0;
						break;
				}
			}	
			
			private function locationChange():void
			{
				var index:int = maptoolLocationCombo.selectedIndex;
				if (index >= locationsList.length)
					return;
				maptoolsLocation.value = index;
			}
			
			private function clearMapcontroLocations():void
			{
				mapControls.right = null;
				mapControls.bottom = null;
				mapControls.left = null;
				mapControls.top = null;
			}
			
			public const sizeFactorOfMapControls:LinkableNumber = registerLinkableChild(this, new LinkableNumber(1, verifySizeFactor), handleSizeFactorChange, true);
			
			public function handleSizeFactorChange():void 
			{
				if (!parent)
				{
					callLater(handleSizeFactorChange);
					return;
				}
				
				mapControls.scaleX = sizeFactorOfMapControls.value;
				mapControls.scaleY = sizeFactorOfMapControls.value;
			}
			private function verifySizeFactor(value:Number):Boolean
			{
				return value >= 1;
			}
			
			// BACKWARDS COMPATIBILITY
			[Deprecated(replacement="visualization.zoomToSelection")] public function get zoomToSelection():Function { return visualization.plotManager.zoomToSelection; }
		]]>
	</mx:Script>

	<mx:VBox id="mapControls"
			 	visible="{enableZoomToggle.selected}"
			 	includeInLayout="{enableZoomToggle.selected}"
				horizontalAlign="center"
				verticalGap="{zoomControlsToggle.selected ? 2 : 0}"
				horizontalScrollPolicy="off" verticalScrollPolicy="off"
				paddingLeft="2" paddingRight="2" paddingBottom="2" paddingTop="2"
				backgroundColor="white" backgroundAlpha="0.01">
		<mx:VBox paddingLeft="2" paddingRight="2" paddingBottom="2" paddingTop="2"
				includeInLayout="{zoomControlsToggle.selected}"
				visible="{zoomControlsToggle.selected}"
				verticalGap="2">
			
			<mx:VBox id="panControls" horizontalAlign="center" verticalGap="1" height="100%">
				<mx:Button id="north"
							label="N"
							fillAlphas="[1.0, 1.0, 1.0, 1.0]"
							width="16" height="16"
							click="handlePanButtonClick(0,1)"
							labelPlacement="left" fontSize="10" paddingBottom="0" paddingLeft="0" paddingRight="0" paddingTop="0" cornerRadius="0" textAlign="center"
							/>
				
				<mx:HBox horizontalGap="2">			
					<mx:Button id="west"
						    label="W" toolTip=""
							fillAlphas="[1.0, 1.0, 1.0, 1.0]"
							width="16" height="16"
							click="handlePanButtonClick(-1,0)"
							 labelPlacement="left" fontSize="10" paddingBottom="0" paddingLeft="0" paddingRight="0" paddingTop="0" cornerRadius="0" textAlign="center"/>
					<mx:Button id="zoomToExtentButton"
							   toolTip="Click this button to zoom to map's full extent"
							   icon="@Embed(source='/weave/resources/images/zoomToExtent.png')"
							   fillAlphas="[1,1]" 
							   width="16" height="16" 
							   cornerRadius="0"
							   click="visualization.zoomToSelection()"/>
					<mx:Button id="east"
						    label="E"
							fillAlphas="[1.0, 1.0, 1.0, 1.0]"
							width="16" height="16"
							click="handlePanButtonClick(1,0)"
							labelPlacement="left" fontSize="10" paddingBottom="0" paddingLeft="0" paddingRight="0" paddingTop="0" cornerRadius="0" textAlign="center"/>
				</mx:HBox>
				
				<mx:Button id="south"
							label="S"
							fillAlphas="[1.0, 1.0, 1.0, 1.0]"
							width="16" height="16"
							click="handlePanButtonClick(0,-1)"
							labelPlacement="left" fontSize="10" paddingBottom="0" paddingLeft="0" paddingRight="0" paddingTop="0" cornerRadius="0" textAlign="center"/>
			</mx:VBox>
		</mx:VBox>
		
		<mx:VBox paddingLeft="2" paddingRight="2" paddingBottom="2" paddingTop="2"
				verticalGap="2"
				includeInLayout="{zoomControlsToggle.selected}"
				visible="{zoomControlsToggle.selected}"
				backgroundColor="white" backgroundAlpha="0.85" borderStyle="outset">
			<mx:Button id="zoomIn"
					icon="@Embed(source='/weave/resources/images/zoomPlus.png')"
					fillAlphas="[1.0, 1.0, 1.0, 1.0]"
					width="15" height="15"
					click="handleZoomInClick()"
					cornerRadius="0" paddingBottom="0" paddingLeft="0" paddingRight="0" paddingTop="0" textAlign="center"/>
			
			<mx:VSlider id="zoomSlider"
						showDataTip="false"
						allowTrackClick="true"
						liveDragging="true"
						tickInterval="1"
						minimum="{zoomSliderMinimum}"
						maximum="{zoomSliderMaximum}"
						height="88"
						change="handleZoomSliderChange(event);"/>
			
			<mx:Button id="zoomOut"
					icon="@Embed(source='/weave/resources/images/zoomMinus.png')"
					fillAlphas="[1.0, 1.0, 1.0, 1.0]"
					width="15" height="15"
					 click="handleZoomOutClick()"
					 cornerRadius="0" paddingBottom="0" paddingLeft="0" paddingRight="0" paddingTop="0" textAlign="center"/>
		</mx:VBox>
		
		<mx:Spacer height="5" includeInLayout="{zoomControlsToggle.selected}"/>
	
		<!--rollOver="mouseModeBox.alpha = 1" rollOut="mouseModeBox.alpha = 0"-->
		<mx:HBox id="mouseModeBox" horizontalGap="1" right="2" bottom="2"  
				 includeInLayout="{mouseModeControlsToggle.selected}"
				 visible="{mouseModeControlsToggle.selected}"
				 backgroundColor="white" backgroundAlpha="0.01"
				 alpha="1"> 
			<mx:Button id="panModeButton" 
				icon="@Embed(source='/weave/resources/images/cursor_hand.png')"
				fillAlphas="[1,1]"  fillColors="{panModeButton.selected ? [0xFF8080, 0xFF8080] : [0x808080, 0x808080]}"
				alpha="{panModeButton.selected ? 1 : 0.5}"
				width="17" height="17" 
				toggle="true"
				toolTip="Select this mode to enable panning on the map using the mouse."
				click="handleMouseModeChange(event)" cornerRadius="0"/>
			<mx:Button id="selectModeSubtractButton"
				icon="@Embed(source='/weave/resources/images/selectMode_subtract.png')"
				fillAlphas="[1,1]"  fillColors="{selectModeSubtractButton.selected ? [0xFF8080, 0xFF8080] : [0x808080, 0x808080]}"
				alpha="{selectModeSubtractButton.selected ? 1 : 0.5}" 
				width="0" minWidth="0" height="17" 
				visible="false"
				toggle="true"
				toolTip="Select this mode to enable subtracting selections from existing selections of shapes on the map using the mouse."
				click="handleMouseModeChange(event)" cornerRadius="0"
				/>
			<mx:Button id="selectModeButton"
				icon="@Embed(source='/weave/resources/images/selectMode.png')"
				fillAlphas="[1,1]"  fillColors="{selectModeButton.selected ? [0xFF8080, 0xFF8080] : [0x808080, 0x808080]}"
				alpha="{selectModeButton.selected ? 1 : 0.5}"
				width="17" height="17"
				toggle="true"
				toolTip="Select this mode to enable adding selections to existing selections of shapes on the map using the mouse."
				click="handleMouseModeChange(event)" cornerRadius="0"
				selected="true"/>
			<mx:Button id="selectModeAddButton"
				icon="@Embed(source='/weave/resources/images/selectMode_add.png')"
				fillAlphas="[1,1]"  fillColors="{selectModeAddButton.selected ? [0xFF8080, 0xFF8080] : [0x808080, 0x808080]}"
				alpha="{selectModeAddButton.selected ? 1 : 0.5}"
				width="0" minWidth="0" height="17"
				visible="false"
				toggle="true"
				toolTip="Select this mode to enable selection of shapes on the map using the mouse."
				click="handleMouseModeChange(event)" cornerRadius="0"
				/>
			<mx:Button id="zoomModeButton"
				icon="@Embed(source='/weave/resources/images/zoomMode.png')"
				fillAlphas="[1,1]" fillColors="{zoomModeButton.selected ? [0xFF8080, 0xFF8080] : [0x808080, 0x808080]}"
				alpha="{zoomModeButton.selected ? 1 : 0.5}"
				width="17" height="17" 
				toggle="true"
				toolTip="Select this mode to enable zooming on the map using the mouse to create a box around the area you want to zoom into."
				click="handleMouseModeChange(event)" cornerRadius="0"/>
		</mx:HBox>
	</mx:VBox>
	

	<ui:ControlPanel>
		<mx:VBox id="attributesPanel" label="Map Layers">
			<mx:HBox width="100%">
				<mx:Button label="Add Base Map" click="addWMSLayer();" toolTip="Add an image layer underneath the geometries"/>
				<mx:Button label="Add Geometry" click="addGeomLayer();" toolTip="Add a layer of polygons, lines, or points that can be colored according to the data"/>
				<mx:Button label="Add Labels" click="addLabelLayer();" toolTip="Add labels to the selected geometry layer"/>
				<!--<mx:Button label="Add relations" click="addRelationLayer();" toolTip="Add relations to the selected geometry layer"/>-->
			</mx:HBox>
			
			<!--<mx:DataGrid dataProvider="{_layerNames.reverse()}">
			<mx:columns>
			<mx:DataGridColumn headerText="Visible"/>
			<mx:DataGridColumn headerText="Probe" headerWordWrap="true"/>
			<mx:DataGridColumn headerText="Geography"/>
			<mx:DataGridColumn headerText="Edit"/>
			<mx:DataGridColumn headerText="Remove"/>
			</mx:columns>
			</mx:DataGrid>-->
			
			<managers:PlotLayerEditor id="layerEditor" creationComplete="layerEditor.visualization = visualization"/>
			<mx:HBox width="100%" verticalAlign="middle">
				<ui:DynamicColumnComponent label="color" showLinkControl="false" visTool="{this}" creationComplete="(event.target as DynamicColumnComponent).dynamicObject = colorColumn"/>
				<mx:Button label="Edit Bins..." click="DraggablePanel.openStaticInstance(ColorController);"/>
			</mx:HBox>
		</mx:VBox>
		<mx:VBox label="Advanced" verticalGap="10">
			<mx:CheckBox label="Enable Map Overview Window" id="overviewCheckBox"
						 creationComplete="linkBindableProperty(enableOverview,event.target,'selected')"/>
			<mx:HBox verticalAlign="bottom">
				<mx:Button label="Zoom to full extent" click="visualization.zoomToSelection()" />
				<mx:VBox verticalGap="1">
					<mx:Label text="Coordinates at map center:" fontWeight="bold"/>
					<mx:HBox horizontalGap="0" borderStyle="outset" horizontalAlign="center">
						<mx:Label text="(x: "/>
						<!--<mx:TextInput id="xCenterCoord" width="50" change="setCenterCoords()" editable="false"/>-->
						<mx:Label id="xCenterCoord" width="75"/>
						<mx:Label text=", y: "/>
						<!--<mx:TextInput id="yCenterCoord" width="50" change="setCenterCoords()" editable="false"/>-->
						<mx:Label id="yCenterCoord" width="75"/>
						<mx:Label text=")"/>
					</mx:HBox>
				</mx:VBox>
			</mx:HBox>
			<mx:HBox verticalAlign="middle" horizontalAlign="center">
				<mx:Label text="Projection"/> 
				<ui:CustomComboBox id="projComboBox"
								   dataProvider="{_projComboBoxData}"
								   creationComplete="linkBindableProperty(projectionSRS, event.target, 'text');"
								   change="handleProjectionComboChange();"
								   focusOut="projComboBox.selectedItem = projectionSRS.value; projValidLabel.text = '';"
								   editable="true"
								   width="120"
								   />
				<!--<mx:TextInput id="projTextInput"
				creationComplete="linkBindableProperty(projectionSRS, event.target, 'text');"
					change="projValidLabel.text = projectionVerifier(projTextInput.text) ? 'Valid' : 'Invalid';"
					focusOut="projTextInput.text = projectionSRS.value; projValidLabel.text = '';"
					/>-->
				<mx:Label id="projValidLabel" fontWeight="bold"/>
			</mx:HBox>
			<mx:CheckBox id="probeColumnsCheckBox" label="Include tool attributes in probe tooltip"
						 toolTip="Checking this box makes all of the tool's attributes visible in this tool's probe tooltip"
						 creationComplete="linkBindableProperty(includeToolAttributesInProbe,event.target,'selected')"/>
			<mx:CheckBox id="enableZoomToggle" label="Enable panning and zooming"
						 creationComplete="linkBindableProperty(visualization.enableZoomAndPan,event.target,'selected')"/>
			<mx:CheckBox id="zoomControlsToggle" label="Show zoom controls"
						 enabled="{enableZoomToggle.selected}"
						 toolTip="This option enables the zoom slider and pan buttons"
						 creationComplete="linkBindableProperty(showZoomControls,event.target,'selected')"/>
			<mx:CheckBox id="mouseModeControlsToggle" label="Show mouse mode controls"
						 enabled="{enableZoomToggle.selected}"
						 toolTip="This option enables the mouse mode buttons"
						 creationComplete="linkBindableProperty(showMouseModeControls,event.target,'selected')"/>
			<mx:HBox verticalAlign="middle" horizontalAlign="center">
				<mx:Label text="Zoom controls location:"/> 
				<ui:CustomComboBox id="maptoolLocationCombo" dataProvider="{locationsList}" change="locationChange()"/>
			</mx:HBox>
			<mx:HBox>
				<mx:Label text="Zoom controls widget scale:" />
				<mx:NumericStepper maximum="2" minimum="1" stepSize=".05" creationComplete="linkBindableProperty(sizeFactorOfMapControls, event.target, 'value')"/>
			</mx:HBox>
			<mx:HBox>
				<mx:Label text="Zoom factor for mouse wheel and zoom buttons:" />
				<mx:NumericStepper maximum="10" minimum="1" stepSize=".25" creationComplete="linkBindableProperty(this.visualization.zoomFactor, event.target, 'value')"/>
			</mx:HBox>
			<mx:HBox>
				<mx:HBox>
					<mx:Label text="Minimum zoom level:" />
					<mx:NumericStepper minimum="0" stepSize="1" creationComplete="linkBindableProperty(this.visualization.plotManager.minZoomLevel, event.target, 'value'); linkBindableProperty(this.visualization.plotManager.maxZoomLevel, event.target, 'maximum')"/>
				</mx:HBox>
				<mx:HBox>
					<mx:Label text="Maximum zoom level:" />
					<mx:NumericStepper maximum="100" stepSize="1" creationComplete="linkBindableProperty(this.visualization.plotManager.maxZoomLevel, event.target, 'value'); linkBindableProperty(this.visualization.plotManager.minZoomLevel, event.target, 'minimum')"/>
				</mx:HBox>
			</mx:HBox>

		</mx:VBox>
		<mx:VBox label="Layer Visibility" verticalGap="10" id="visibleScaleRangesUI">
			<ui:Indent label="Current Zoom" labelTextAlign="left" group="{scaleRangeIndentGroup}">
				<mx:HSlider id="scaleRangeTabZoomSlider" 
							width="100%" 
							tickInterval="1"
							change="handleZoomSliderChange(event);"
							minimum="{zoomSliderMinimum}"
							maximum="{zoomSliderMaximum}"
							liveDragging="true" />
			</ui:Indent>
			<ui:LinkableObjectList id="visibleScaleRangesList"
								   width="100%" height="100%"
								   initialize="visibleScaleRangesList.hashMap = visualization.plotManager.layerSettings"
								   borderStyle="none"
								   paddingLeft="0">
				<ui:itemRenderer>
					<mx:Component>
						<ui:Indent label="{layerName}" labelTextAlign="left" group="{outerDocument.scaleRangeIndentGroup}" creationComplete="handleCreationComplete()">
							<mx:Script>
								<![CDATA[
									import weave.compiler.StandardLib;
									import mx.events.SliderEvent;
									
									import weave.api.getCallbackCollection;
									import weave.core.CallbackJuggler;
									import weave.core.UIUtils;
									import weave.utils.ZoomUtils;
									import weave.visualization.layers.LayerSettings;
									import weave.visualization.layers.PlotManager;
									
									[Bindable] private var layerName:String;
									
									private var currentlyUpdatingLayerZoomRangeSlider:Boolean = false;
									
									private function handleCreationComplete():void
									{
										getCallbackCollection(pm.zoomBounds).addGroupedCallback(outerDocument, handleSettingsChange);
										getCallbackCollection(pm.minScreenSize).addGroupedCallback(outerDocument, handleSettingsChange);
									}
									
									private function get pm():PlotManager { return outerDocument.visualization.plotManager; }
									private function get settings():LayerSettings { return data as LayerSettings; }
									
									override public function set data(value:Object):void
									{
										super.data = settingsJuggler.target = value as LayerSettings;
									}
									
									private const settingsJuggler:CallbackJuggler = new CallbackJuggler(outerDocument, handleSettingsChange, true);
									private function handleSettingsChange():void
									{
										if (!settings)
											return;
										
										layerName = pm.layerSettings.getName(settings);
										var area:Number = pm.fullDataBounds.getArea();
										if (!isNaN(area))
										{
											var minZoomLevel:Number = ZoomUtils.getZoomLevelFromScale(
												pm.fullDataBounds, pm.minScreenSize.value, settings.minVisibleScale.value
											);
											
											var maxZoomLevel:Number = ZoomUtils.getZoomLevelFromScale(
												pm.fullDataBounds, pm.minScreenSize.value, settings.maxVisibleScale.value
											);
											
											currentlyUpdatingLayerZoomRangeSlider = true;
											var newValues:Array = [minZoomLevel, maxZoomLevel];
											if (StandardLib.arrayCompare(layerZoomRangeSlider.values, newValues) == 0)
												layerZoomRangeSlider.values = [NaN, NaN];
											layerZoomRangeSlider.values = newValues;
											currentlyUpdatingLayerZoomRangeSlider = false;
										}
									}
									
									private function handleScaleSliderChange(event:SliderEvent):void
									{
										if (data && !currentlyUpdatingLayerZoomRangeSlider && UIUtils.hasFocus(layerZoomRangeSlider))
										{
											var minScreenSize:Number = pm.minScreenSize.value;
											var minVisibleZoomLevel:Number = layerZoomRangeSlider.values[0];
											var maxVisibleZoomLevel:Number = layerZoomRangeSlider.values[1];
											
											data.minVisibleScale.value = ZoomUtils.getScaleFromZoomLevel(
												pm.fullDataBounds, minScreenSize, minVisibleZoomLevel
											);
											
											data.maxVisibleScale.value = ZoomUtils.getScaleFromZoomLevel(
												pm.fullDataBounds, minScreenSize, maxVisibleZoomLevel
											);
										}
									}
								]]>
							</mx:Script>
							
							<mx:HSlider id="layerZoomRangeSlider"
										liveDragging="true"
										thumbCount="2"
										tickInterval="1"
										snapInterval="{outerDocument.zoomSliderSnapping}"
										showTrackHighlight="true" 
										minimum="{outerDocument.zoomSliderMinimum}" 
										maximum="{outerDocument.zoomSliderMaximum}"
										change="handleScaleSliderChange(event)"
										mouseDown="event.target.setFocus(); event.stopPropagation()"
										width="100%"/>
						</ui:Indent>
					</mx:Component>			
				</ui:itemRenderer>
			</ui:LinkableObjectList>
		</mx:VBox>
	</ui:ControlPanel>
	<ui:IndentGroup id="scaleRangeIndentGroup"/>
	<mx:Number id="zoomSliderMinimum"/>
	<mx:Number id="zoomSliderMaximum"/>
	<mx:Number id="zoomSliderSnapping">0.25</mx:Number>
</SimpleVisTool>
